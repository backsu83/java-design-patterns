# SOLID 원칙

## 1. 단일책임 원칙(Single Responsibility Principle)

#### 1.1 책임의 의미
객체 지향 설계관점에서는 SRP에서 말하는 책임의 기본단위는 객체를 말한다. 
**즉, 객체는 단 하나의 책임만을 가져야한다는 의미이다.**

그렇다면 책임이란 무엇일까?
책임을 여러관점에서 해석할 수 있지만 보통 "해야 하는 것"이나 "할 수 있는 것"으로 간주된다.
객체에 책을 할달할 때는 어떤 객체보다도 작업을 잘할 수 있는 객체에 책임을 할당해야한다. 

**다시 책임을 한마디로 정리해보자면 객체가 해야하는 것을 잘하는 것이라고 할 수 있다.**

예를 들어 학생 클래스가 수강 과목을 추가하거나 조회하고, 데이터베이스에 객체 정보를 저장하거나 데이터베이스에서 객체정보를 읽는 작업도 처리하고, 성적표와 출석부도 출력하는 일도 한다고 가정해보자.
그렇다면 아래와 같은 클래스로 코드를 작성할 수 있을 것이다.

```java
public class Student {
    
    public void getCourses(){}
    public void addCourse(Course course){}
    public void save(){}
    public Student load(){}
    public void printOnReportCard(){}
    public void printOnAttendanceBook(){}
    
}
```

위의 코드를 보면 학생 클래스가 너무나 많은 책임을 수행하고 있다. 학생 클래스에서 가장 잘할 수 있는 것을 생각해보면 수강 과목을 추가하거나 조회하는 것이다.
나머지 기능들은 학생 클래스가 아닌 다른 클래스에서 더 잘할 수 있을 여지가 많다. 그래서 학생 클래스는 수강과목을 조회하고, 추가하는 책임만을 수행하도록 하는 것이 바람직하다.

```java
public class Student {
    
    public void getCourses(){}                  // 학생 클래스에서 잘할 수 있는 것
    public void addCourse(Course course){}      // 학생 클래스에서 잘할 수 있는 것
    // public void save(){}                     // 다른 클래스에서 잘할 수 있는 것
    // public Student load(){}                  // 다른 클래스에서 잘할 수 있는 것
    // public void printOnReportCard(){}        // 다른 클래스에서 잘할 수 있는 것
    // public void printOnAttendanceBook(){}    // 다른 클래스에서 잘할 수 있는 것
    
}
```

#### 1.2 변경
SRP를 따르는 실효성 있는 설계가 되려면 책임을 좀 더 현실적인 개념으로 파악할 필요가 있다.
설계원칙을 공부하는 이유는 예측하지 못한 변경사항이 발생하더라도 유연하고 확장성이 있도록 시스템 구조를 설계하기 위해서이다.
좋은 설계란 기본적으로 시스템에 새로운 요구사항이나 변경이 있을 때 가능한 영향을 받는 부분을 줄여야 한다.
어떤 클래스가 잘 설계되었는지를 판단하려면 언제 변경되어야 하는지를 물어보는 것이 좋다.

그럼 이전에 살펴본 학생클래스는 언제 변경되어야할까? 이 물음을 답하기 위해서는 학생 클래스의 변경 이유를 찾아보는 것이 좋다.

- 데이터베이스 스키마가 변경된다면 학생 클래스도 변경되어야하는가?
- 학생이 지도교수를 찾는 기능이 추가되어야 한다면 학생 클래스는 영향을 받는가?
- 학생 정보를 성적표와 출석부 이외의 형식으로 출력해야한다면 어떻게 해야하는가?

위의 질문이 학생 클래스를 변경해야하는 이유가 될 수 있다.

![변경의 영향]()

위의 그림에서 처럼 또한 책임이 많아질수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합될 가능성이 높다.
예를 들어 현재 수강과목을 조회하는 코드와 데이터베이스의 학생정보를 가져오는 코드가 연결될 수 도 있고, 학생이 수강 과목을 추가하는 코드와 데이터베이스 학생 정보를 갱신하는 코드가 서로 연결될 수도 있다.



#### 1.3 책임 분리

#### 1.4 산탄총 수술

#### 1.5 관심지향 프로그래밍과 횡단 관심 문제


## 2. 개방-폐쇄 원칙(Open-Closed Principle)

## 3. 리스코프 치환 원칙(Liskov Substitution Principle)

## 4. 의존역전 원칙(Dependency Inversion Principle)

## 5. 인터페이스 분리 원칙(Interface Segregation Principle)
