# 객체지향의 원리

## 1. 추상화

#### 1.1 추상화란?

**추상화란 어떤 영역에서 필요로 하는 속성이나 행동을 추출하는 작업을 의미한다. 추상화를 통해 관심이 쏠리는 부분에 더욱 집중을 할 수 있다.**

#### 1.2 추상화의 예

예를 들어 넓은 주차장에 수많은 자동차들이 주차되어있다고 가정해보자. 이 자동차들을 그룹화할 때 추상화 개념을 사용할 수 있다.
어떤 사람은 사람이 탈 수 있는 승객의 수를 기준으로 승합차와 승용차로 그룹화 할 수 있고, 또다른 어떤 사람은 문의 개수에 따라 세단과 쿠페로 그룹화 할 수 있다.

- 자동차 승객 수에 따른 분류
    - 승용차
    - 승합차
    
- 자동차 문의 수에 따른 분류
    - 세단
    - 쿠페
    
위에서 예로 든 것처럼 **구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념 집합으로 다루는 수단이 추상화다.**
추상화는 객체지향 프로그래밍에서 매우 중요한데 만약 추상화가 없다면 각각의 개체를 각각 구분해야할 것이다. 

예를 들어 자동차마다 엔진오일을 교환하는 방식이 다르다고 가정해보자. 그렇다면 아래와 같은 코드가 작성될 것이다.

```
switch(자동차 종류)
    case 아우디: break;    // 아우디 엔진오일을 교환하는 과정
    case 벤츠: break;     // 벤츠 엔진오일을 교환하는 과정
```

이때 만약 BMW와 같은 새로운 종류의 엔진오일을 교환하는 기능을 추가하라는 요구사항이 있을 경우 아래와 같이 코드가 변경될 것이다.

```
switch(자동차 종류)
    case 아우디: break;    // 아우디 엔진오일을 교환하는 과정
    case 벤츠: break;     // 벤츠 엔진오일을 교환하는 과정
    case BMW: break;     // BMW 엔진오일을 교환하는 과정
```

위 코드의 문제점은 새로운 자동차가 추가될 때마다 새로운 코드를 작성해주어야하는 불편함이 발생한다. 이러한 불편함을 해결할 방법은 아래와 같다.

아우디, 벤츠, BMW와 같은 구체적인 자동차 대신 이들의 추상화 개념인 자동차를 이용할 경우 아래와 같이 코드를 작성할 수 있다.

```
void changeEngineOil(Car car) {
    car.changeEngineOil();
}
```


프로시저 `changeEngineOil`의 인자로 아우디, 벤츠의 추상개념인 Car를 사용하는데 인자 어느 곳에서도 구체적인 자동차 종류와 연관된 부분을 찾을 수 없게 되었다.
따라서 이 코드는 어떤 새로운 자동차가 추가되더라도 코드가 변경될 일이 없어진다. 
대신 인자 `car`가 가리키는 구체적인 자동차의 종류에 따라 `changeEngineOil`메서드가 다르게 실행되어야한다. 이는 일반화 관계에서 설명할 다형성 원리에 따르게 된다.

**추상화를 통해 각 개체의 구체적인 개념에 의존하지 말고 추상적인 개념에 의존해야 설계를 유연하게 변경할 수 있다는 점에 주목하자.**

## 2. 캡슐화

#### 1.1 캡슐화란?

소프트웨어 개발을 할 때 요구사항 변경에 유연하게 대처하기 위해서는 높은 응집도와 낮은 결합도를 유지하는 것이 중요하다.
- 응집도 : 클래스나 모듈 안의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타낸다.
- 결합도 : 어떤 기능을 실행하는데 다른 클래스나 모듈들에 얼마나 의존적인지 나타낸다.

캡슐화는 특히 낮은 결합도를 유지할 수 있도록 해주는 객체지향의 원리이다. 캡슐화는 정보은닉을 통해 높은 응집도와 낮은 결합도를 갖도록 한다.
- 정보은닉 : 알 필요가 없는 정보는 외부에서 접근하지 못하도록 제한하는 것을 말한다.

예를 들어 자동차의 가속 페달을 밟았을 때 어떤 과정을 거쳐 속도가 올라가는지 모르더라도 운전하는데 전혀 지장이 없다. 세탁기도 역시 어떤과정을 거쳐 세탁기의 드럼이 동작하는지 모르더라도 옷을 세탁하는데 전혀 지장이 없다.

그렇다면 정보은닉은 왜 필요한 것인가?

소프트웨어는 결합이 많을수록 문제가 많이 발생하게 된다. 한 클래스가 변경이 발생하면 변경된 클래스의 비밀에 의존하는 다른 클래스도 변경해야할 가능성이 커지는 것이다.
그렇기 때문에 정보은닉을 통해 클래스간의 결합도를 낮추고, 응집도를 높여 변경되는 사항에 유연하게 대처하는 것이 바람직하다.

#### 1.2 캡슐화 예제

- 캡슐화 예제 1 : `ArrayStack`클래스와 `StackClient`클래스 간의 결합도 증가

- 캡슐화 예제 2 : `ArrayStack`클래스와 `StackClient`클래스 간의 결합도 감소, 응집도 증가

## 3. 일반화

#### 3.1 일반화 관계
일반적으로 객체지향 개념에서 가장 많이 오해하고, 오용하는 것이 일반화 관계이다. 일반화 관계는 객체지향 프로그래밍 관점에서 상속관계라 한다.
따라서 속성이나 기능의 재사용만을 강조해서 사용하는 경우가 많다. 이는 일반화 관계에서 극히 한정되게 바라보는 시각이다.

철학에서 말하는 일반화는 "여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정"이라고 한다. 
예를 들어 설명해보면 사과, 바나나, 오렌지 등이 가진 공통된 개념은 과일이라고 할수 있다. 과일은 사과, 바나나, 오렌지 등이 가진 공통 개념을 일반화한 개념이며 사과, 바나나, 오렌지는 과일의 한 종류이기므로 과일을 특수화한 개념이다.
그런데 만약 이러한 일반화, 특수화 관계가 없다면 냉장고에 과일이 몇개있는지 질문하기 위해서는 하나의 과일마다 따로 질문을 해야만하는 상황이 올지도 모른다.

- 일반화 관계가 없다면?
    - 냉장고에 사과가 몇개 있지?
    - 그리고 냉장고에 바나나가 몇개 있지?
    - 그리고 또 배가 몇개 있지?
    - 오렌지는 또 몇개가 있지?
- 일반화 관계를 통해 하나의 질문으로 통합할 수 있다.
    - 냉장고에 과일은 몇개가 있지?
    
그렇다면 과일의 전체 가격을 구하는 코드를 작성해보자.

```
가격 총합 = 0
while(장바구니에 과일이 있다) {
    switch(과일 종류)
        case 사과:
            가격총합 = 가격총합 + 사과가격
        case 배:
            가격총합 = 가격총합 + 배가격
        case 바나나:
            가격총합 = 가격총합 + 바나나가격
}
```

만약 오렌지를 추가해야된다면? 아래의 코드처럼 변경될 것이다.

```
가격 총합 = 0
while(장바구니에 과일이 있다) {
    switch(과일 종류)
        case 사과:
            가격총합 = 가격총합 + 사과가격
        case 배:
            가격총합 = 가격총합 + 배가격
        case 바나나:
            가격총합 = 가격총합 + 바나나가격
        case 오렌지:
            가격총합 = 가격총합 + 오렌지가격
}
```

위와 같이 새로운 과일이 등장할 때마다 코드를 일일히 수정해줘야하는 번거로움이 발생하게되고 변경사항에 유연하게 대처가 어렵게된다.

그렇다면 어떻게 수정되어야할까? 아래의 코드를 통해 알아보자.

```
int computeTotalPrice(LinkedList<Fruit> fruit) {
    int total = 0;
    Iterator<Fruit> iterator = fruit.iterator();
    
    while(hasNext()) {
        Fruit currentFruit = iterator.next();
        total = total + currentFruit.calculatePrice();
    }
    return total;
}
``` 
이렇게 수정된다면 어떠한 과일이 추가되더라도 코드를 수정할 필요가 없어지게 된다. 여기서`calculatePrice()`는 실제 과일 객체의 종류에 따라 각가 다르게 실행하게 된다.
이것은 다형성에 따른 것인데 추후 다형성을 정리하면서 알아보자.

지금까지 정리한 내용을 통해서 알수 있는 것은 일반화 관계는 외부에 자식 클래스를 캡슐화하는 개념으로 볼 수 있다. 캡슐화의 개념이 단순히 한 클래스 안에 있는 속성과 연산들의 캡슐화에 한정되지 않고, 일반화를 통해 클래스 자체를 캡슐화하는 것으로 확장된다.
이러한 서브 클래스 캡슐화는 외부 클라이언트가 개별적인 클래스들과 무관하게 프로그래밍을 할 수 있게 해준다.



#### 3.2 일반화 관계와 위임

#### 3.3 집합론 관점에서 본 일반화 관계


## 4. 다형성

#### 4.1 다형성이란?