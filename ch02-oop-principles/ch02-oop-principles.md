# 객체지향의 원리

## 1. 추상화

#### 1.1 추상화란?

**추상화란 어떤 영역에서 필요로 하는 속성이나 행동을 추출하는 작업을 의미한다. 추상화를 통해 관심이 쏠리는 부분에 더욱 집중을 할 수 있다.**

#### 1.2 추상화의 예

예를 들어 넓은 주차장에 수많은 자동차들이 주차되어있다고 가정해보자. 이 자동차들을 그룹화할 때 추상화 개념을 사용할 수 있다.
어떤 사람은 사람이 탈 수 있는 승객의 수를 기준으로 승합차와 승용차로 그룹화 할 수 있고, 또다른 어떤 사람은 문의 개수에 따라 세단과 쿠페로 그룹화 할 수 있다.

- 자동차 승객 수에 따른 분류
    - 승용차
    - 승합차
    
- 자동차 문의 수에 따른 분류
    - 세단
    - 쿠페
    
위에서 예로 든 것처럼 **구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념 집합으로 다루는 수단이 추상화다.**
추상화는 객체지향 프로그래밍에서 매우 중요한데 만약 추상화가 없다면 각각의 개체를 각각 구분해야할 것이다. 

예를 들어 자동차마다 엔진오일을 교환하는 방식이 다르다고 가정해보자. 그렇다면 아래와 같은 코드가 작성될 것이다.

```
switch(자동차 종류)
    case 아우디: break;    // 아우디 엔진오일을 교환하는 과정
    case 벤츠: break;     // 벤츠 엔진오일을 교환하는 과정
```

이때 만약 BMW와 같은 새로운 종류의 엔진오일을 교환하는 기능을 추가하라는 요구사항이 있을 경우 아래와 같이 코드가 변경될 것이다.

```
switch(자동차 종류)
    case 아우디: break;    // 아우디 엔진오일을 교환하는 과정
    case 벤츠: break;     // 벤츠 엔진오일을 교환하는 과정
    case BMW: break;     // BMW 엔진오일을 교환하는 과정
```

위 코드의 문제점은 새로운 자동차가 추가될 때마다 새로운 코드를 작성해주어야하는 불편함이 발생한다. 이러한 불편함을 해결할 방법은 아래와 같다.

아우디, 벤츠, BMW와 같은 구체적인 자동차 대신 이들의 추상화 개념인 자동차를 이용할 경우 아래와 같이 코드를 작성할 수 있다.

```
void changeEngineOil(Car car) {
    car.changeEngineOil();
}
```


프로시저 `changeEngineOil`의 인자로 아우디, 벤츠의 추상개념인 Car를 사용하는데 인자 어느 곳에서도 구체적인 자동차 종류와 연관된 부분을 찾을 수 없게 되었다.
따라서 이 코드는 어떤 새로운 자동차가 추가되더라도 코드가 변경될 일이 없어진다. 
대신 인자 `car`가 가리키는 구체적인 자동차의 종류에 따라 `changeEngineOil`메서드가 다르게 실행되어야한다. 이는 일반화 관계에서 설명할 다형성 원리에 따르게 된다.

**추상화를 통해 각 개체의 구체적인 개념에 의존하지 말고 추상적인 개념에 의존해야 설계를 유연하게 변경할 수 있다는 점에 주목하자.**

## 2. 캡슐화

#### 1.1 캡슐화란?

소프트웨어 개발을 할 때 요구사항 변경에 유연하게 대처하기 위해서는 높은 응집도와 낮은 결합도를 유지하는 것이 중요하다.
- 응집도 : 클래스나 모듈 안의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타낸다.
- 결합도 : 어떤 기능을 실행하는데 다른 클래스나 모듈들에 얼마나 의존적인지 나타낸다.

캡슐화는 특히 낮은 결합도를 유지할 수 있도록 해주는 객체지향의 원리이다. 캡슐화는 정보은닉을 통해 높은 응집도와 낮은 결합도를 갖도록 한다.
- 정보은닉 : 알 필요가 없는 정보는 외부에서 접근하지 못하도록 제한하는 것을 말한다.

예를 들어 자동차의 가속 페달을 밟았을 때 어떤 과정을 거쳐 속도가 올라가는지 모르더라도 운전하는데 전혀 지장이 없다. 세탁기도 역시 어떤과정을 거쳐 세탁기의 드럼이 동작하는지 모르더라도 옷을 세탁하는데 전혀 지장이 없다.

그렇다면 정보은닉은 왜 필요한 것인가?

소프트웨어는 결합이 많을수록 문제가 많이 발생하게 된다. 한 클래스가 변경이 발생하면 변경된 클래스의 비밀에 의존하는 다른 클래스도 변경해야할 가능성이 커지는 것이다.
그렇기 때문에 정보은닉을 통해 클래스간의 결합도를 낮추고, 응집도를 높여 변경되는 사항에 유연하게 대처하는 것이 바람직하다.

#### 1.2 캡슐화 예제

- 캡슐화 예제 1 : `ArrayStack`클래스와 `StackClient`클래스 간의 결합도 증가

- 캡슐화 예제 2 : `ArrayStack`클래스와 `StackClient`클래스 간의 결합도 감소, 응집도 증가

## 3. 일반화

#### 3.1 일반화 관계
일반적으로 객체지향 개념에서 가장 많이 오해하고, 오용하는 것이 일반화 관계이다. 일반화 관계는 객체지향 프로그래밍 관점에서 상속관계라 한다.
따라서 속성이나 기능의 재사용만을 강조해서 사용하는 경우가 많다. 이는 일반화 관계에서 극히 한정되게 바라보는 시각이다.

철학에서 말하는 일반화는 "여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정"이라고 한다. 
예를 들어 설명해보면 사과, 바나나, 오렌지 등이 가진 공통된 개념은 과일이라고 할수 있다. 과일은 사과, 바나나, 오렌지 등이 가진 공통 개념을 일반화한 개념이며 사과, 바나나, 오렌지는 과일의 한 종류이기므로 과일을 특수화한 개념이다.
그런데 만약 이러한 일반화, 특수화 관계가 없다면 냉장고에 과일이 몇개있는지 질문하기 위해서는 하나의 과일마다 따로 질문을 해야만하는 상황이 올지도 모른다.

- 일반화 관계가 없다면?
    - 냉장고에 사과가 몇개 있지?
    - 그리고 냉장고에 바나나가 몇개 있지?
    - 그리고 또 배가 몇개 있지?
    - 오렌지는 또 몇개가 있지?
- 일반화 관계를 통해 하나의 질문으로 통합할 수 있다.
    - 냉장고에 과일은 몇개가 있지?
    
그렇다면 과일의 전체 가격을 구하는 코드를 작성해보자.

```
가격 총합 = 0
while(장바구니에 과일이 있다) {
    switch(과일 종류)
        case 사과:
            가격총합 = 가격총합 + 사과가격
        case 배:
            가격총합 = 가격총합 + 배가격
        case 바나나:
            가격총합 = 가격총합 + 바나나가격
}
```

만약 오렌지를 추가해야된다면? 아래의 코드처럼 변경될 것이다.

```
가격 총합 = 0
while(장바구니에 과일이 있다) {
    switch(과일 종류)
        case 사과:
            가격총합 = 가격총합 + 사과가격
        case 배:
            가격총합 = 가격총합 + 배가격
        case 바나나:
            가격총합 = 가격총합 + 바나나가격
        case 오렌지:
            가격총합 = 가격총합 + 오렌지가격
}
```

위와 같이 새로운 과일이 등장할 때마다 코드를 일일히 수정해줘야하는 번거로움이 발생하게되고 변경사항에 유연하게 대처가 어렵게된다.

그렇다면 어떻게 수정되어야할까? 아래의 코드를 통해 알아보자.

```
int computeTotalPrice(LinkedList<Fruit> fruit) {
    int total = 0;
    Iterator<Fruit> iterator = fruit.iterator();
    
    while(hasNext()) {
        Fruit currentFruit = iterator.next();
        total = total + currentFruit.calculatePrice();
    }
    return total;
}
``` 
이렇게 수정된다면 어떠한 과일이 추가되더라도 코드를 수정할 필요가 없어지게 된다. 여기서`calculatePrice()`는 실제 과일 객체의 종류에 따라 각가 다르게 실행하게 된다.
이것은 다형성에 따른 것인데 추후 다형성을 정리하면서 알아보자.

지금까지 정리한 내용을 통해서 알수 있는 것은 일반화 관계는 외부에 자식 클래스를 캡슐화하는 개념으로 볼 수 있다. 캡슐화의 개념이 단순히 한 클래스 안에 있는 속성과 연산들의 캡슐화에 한정되지 않고, 일반화를 통해 클래스 자체를 캡슐화하는 것으로 확장된다.
이러한 서브 클래스 캡슐화는 외부 클라이언트가 개별적인 클래스들과 무관하게 프로그래밍을 할 수 있게 해준다.


아래는 사람이 자동차를 사용하는 상황을 묘사한 것이다.
```
사람 ----------> 자동차 <----------- BMW, 소나타, 벤츠, 아우디
```

사람 클래스 관점에서는 구체적인 자동차의 종류가 숨겨져있는데 대리운전을 한다고 가정해보자. 대리운전자는 자동차 종류에 따라 운전에 영향을 받지 않는다.
이와 같이 새로운 자동차를 운전해야 하는 경우에도 사람 클래스는 영향을 받지 않게 된다.

**일반화 관계는 자식 클래스를 외부로부터 은닉하는 캡슐화의 일종이다**

#### 3.2 일반화 관계와 위임
이전에도 말한 것처럼 많은 사람들이 일반화 관계(상속)를 기능의 상속, 즉 재사용을 위해 존재한다고 오해하고 있다. 하지만 이는 사실이 아니다.

예를 들어 보자. 만약 `ArrayList`를 상속받아 `Stack`클래스를 만든다면 아마 프로그래머의 의도는 `ArrayList`클래스에 정의된 `isEmpty()`, `size()`, `add()`, `remove()` 메서드를 자신이 구현하지 않고 그대로 사용하길 원했을 것이다.
기능의 재사용 측면에서는 성공적이라고 할 수 있게지만`ArrayList`클래스에 정의된 스택과 전혀관련 없는 수많은 연산이나 속성도 함께 상속 받게 된다.
실제로도 이런 불필요한 속성이나 연산은 도움이 되기보다는 물려받고 싶지 않은 빚이 될 가능성이 많다.

실제로 위의 사례와 같이 코드를 작성해보면 아래와 같다.
```java
// 일반화(상속)을 통한 기능 재사용
public class MyStack<String> extends ArrayList<String> {

    public void push(String element) {
        add(element);
    }

    public String pop() {
        return remove(size() - 1);
    }

}
``` 
```java
public class Main {
    public static void main(String[] args) {

        MyStack<String> myStack = new MyStack<>();

        myStack.push("A");
        myStack.push("B");
        myStack.push("C");
        myStack.add("C");   // 허용되어서는 안됨
        myStack.set(0, "D"); // 허용되어서는 안됨

        System.out.println(myStack.pop());
        System.out.println(myStack.pop());
        System.out.println(myStack.pop());

    }
}
```
위와 같이 작성됨에 따라 `push()`, `pop()`메서드를 통하지 않고 스택의 자료구조에 직접 접근할 수 있게 되었다.
하지만 이렇게 됨에 따라 스택의 무결성 조건인 LIFO에 위배된다.

기본적으로 일반화 관계는 "IS A KIND OF 관계"가 성립이 되어야만 한다. 그런 면에서 `MyStack`클래스와 `ArrayList`클래스의 관계가 참인지 판단을 통해 알 수 있다.

> Stack is a kind of ArrayList : 참이 아니다. 왜냐하면 대부분의 프로그램에서 배열목록 대신 스택을 사용할 수 없기 때문이다.

그렇다면 어떤 클래스의 일부 기능만 재사용하고 싶은 경우 어떻게 하는 것이 좋을까?
그것은 바로 *위임* 을 사용하는 것이다. 위임은 자신이 직접 기능을 실행하지 않고 다른 클래스의 객체가 기능을 실행하도록 하는 것이다.

따라서 일반화 관계는 클래스 사이의 관계이지만 위임은 객체 사이의 관계이다.

아래는 위임을 사용하여 일반화(상속)를 대신하는 과정이다.

1. 자식 클래스에 부모 클래스의 인스턴스를 참조하는 속성을 만든다. 이 속성 필드를 `this`로 초기화한다.
2. 서브 클래스에 정의된 각 메서드에 1번에서 만든 위임 속성 필드를 참조하도록 변경한다.
3. 서브 클래스에서 일반환 관계 선언을 제거하고, 위임 속성 필드에 슈퍼 클래스의 객체를 생성해 대입한다.
4. 서브 클래스에서 사용된 슈퍼 클래스의 메서드에도 위임 메서드를 추가한다.
5. 컴파일하고 잘 동작하는지 확인한다.

실제로 `MyStack`클래스에 적용 시키보자.
```java
// 3. 서브 클래스에서 일반화된 관계선언을 제거
public class MyStack<String> {
//public class MyStack<String> extends ArrayList<String> {

    // 1. 자식 클래스에 부모클래스의 인스턴스를 참조하는 속성 생성, this로 초기화
    //private ArrayList<String> arrayList = this;

    // 4. 위임 속성 필드에 슈퍼 클래스의 객체를 생성해 대입
    private ArrayList<String> arrayList = new ArrayList<>();

    // 2. 서브 클래스에 정의된 메서드에 1번에서 만든 위임 속성 필드를 참조하도록 변경
    public void push(String element) {
        //add(element);
        arrayList.add(element);
    }

    // 2. 서브 클래스에 정의된 메서드에 1번에서 만든 위임 속성 필드를 참조하도록 변경
    public String pop() {
        //return remove(size() - 1);
        return arrayList.remove(size() - 1);
    }

    // 5. 서브 클래스에서 사용된 슈퍼 클래스의 메서드에도 위임 메서드를 추가
    public boolean isEmpty() {
        return arrayList.isEmpty();
    }

    // 5. 서브 클래스에서 사용된 슈퍼 클래스의 메서드에도 위임 메서드를 추가
    public int size() {
        return arrayList.size();
    }

}
```

**기능을 재사용할때는 일반화 관계(상속)이 아닌 위임을 이용하자**

#### 3.3 집합론 관점에서 본 일반화 관계
일반화 관계는 수학에서 배우는 집합론과 매우 밀접한 관계가 있다.

아래의 그림은 집합과 일반화의 관계를 보여준다.

![집합론](https://raw.githubusercontent.com/walbatrossw/java-design-patterns/master/ch02-oop-principles/img/oop-design-grouping.png)

부모클래스 A는 전체 집합 A에 해당하고 그 부분 집합 A1, A2, A3는 각각 A의 자식 클래스에 해당한다. 이 때 아래와 같은 관계가 성립되어야 한다.

- A = A1 ∪ A2 ∪ A3
- A1 ∩ A2 ∩ A3 = ∅




## 4. 다형성

#### 4.1 다형성이란?